#!/usr/bin/env python3

from __future__ import print_function
from six.moves import input
import cv2
import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import math
try:
    from math import pi, tau, dist, fabs, cos
except:  # For Python 2 compatibility
    from math import pi, fabs, cos, sqrt

    tau = 2.0 * pi

    def dist(p, q):
        return sqrt(sum((p_i - q_i) ** 2.0 for p_i, q_i in zip(p, q)))


from std_msgs.msg import String
from moveit_commander.conversions import pose_to_list

#altta bütün aruco türleri verildi
ARUCO_DICT = {
    "DICT_4X4_50": cv2.aruco.DICT_4X4_50,
    "DICT_4X4_100": cv2.aruco.DICT_4X4_100,
    "DICT_4X4_250": cv2.aruco.DICT_4X4_250,
    "DICT_4X4_1000": cv2.aruco.DICT_4X4_1000,
    "DICT_5X5_50": cv2.aruco.DICT_5X5_50,
    "DICT_5X5_100": cv2.aruco.DICT_5X5_100,
    "DICT_5X5_250": cv2.aruco.DICT_5X5_250,
    "DICT_5X5_1000": cv2.aruco.DICT_5X5_1000,
    "DICT_6X6_50": cv2.aruco.DICT_6X6_50,
    "DICT_6X6_100": cv2.aruco.DICT_6X6_100,
    "DICT_6X6_250": cv2.aruco.DICT_6X6_250,
    "DICT_6X6_1000": cv2.aruco.DICT_6X6_1000,
    "DICT_7X7_50": cv2.aruco.DICT_7X7_50,
    "DICT_7X7_100": cv2.aruco.DICT_7X7_100,
    "DICT_7X7_250": cv2.aruco.DICT_7X7_250,
    "DICT_7X7_1000": cv2.aruco.DICT_7X7_1000,
    "DICT_ARUCO_ORIGINAL": cv2.aruco.DICT_ARUCO_ORIGINAL,
    "DICT_APRILTAG_16h5": cv2.aruco.DICT_APRILTAG_16h5,
    "DICT_APRILTAG_25h9": cv2.aruco.DICT_APRILTAG_25h9,
    "DICT_APRILTAG_36h10": cv2.aruco.DICT_APRILTAG_36h10,
    "DICT_APRILTAG_36h11": cv2.aruco.DICT_APRILTAG_36h11
}

TARGET_MARKER_ID = 1 # Hedef ArUco işareti ID'si

#alttaki fonksiyon tutoriallerden alındı ama nasıl kullanıdlığını bilmiyorum
def all_close(goal, actual, tolerance):
    """
    Convenience method for testing if the values in two lists are within a tolerance of each other.
    For Pose and PoseStamped inputs, the angle between the two quaternions is compared (the angle
    between the identical orientations q and -q is calculated correctly).
    @param: goal       A list of floats, a Pose or a PoseStamped
    @param: actual     A list of floats, a Pose or a PoseStamped
    @param: tolerance  A float
    @returns: bool
    """
    if type(goal) is list:
        for index in range(len(goal)):
            if abs(actual[index] - goal[index]) > tolerance:
                return False

    elif type(goal) is geometry_msgs.msg.PoseStamped:
        return all_close(goal.pose, actual.pose, tolerance)

    elif type(goal) is geometry_msgs.msg.Pose:
        x0, y0, z0, qx0, qy0, qz0, qw0 = pose_to_list(actual)
        x1, y1, z1, qx1, qy1, qz1, qw1 = pose_to_list(goal)
        # Euclidean distance
        d = dist((x1, y1, z1), (x0, y0, z0))
        # phi = angle between orientations
        cos_phi_half = fabs(qx0 * qx1 + qy0 * qy1 + qz0 * qz1 + qw0 * qw1)
        return d <= tolerance and cos_phi_half >= cos(tolerance / 2.0)

    return True

def main_position(): #robotu simülasyonda ana konumuna döndürür 
	
	group_name = "manipulator"
	move_group = moveit_commander.MoveGroupCommander(group_name)

	
	joint_goal = move_group.get_current_joint_values()
	#alttaki her değişken robotun başka bir eklemini temsil eder ve radyan cinsinden değer alır
	
	joint_goal[0] = 0
	joint_goal[1] = -2.09
	joint_goal[2] = 1.745
	joint_goal[3] = 0.349
	joint_goal[4] = 1.5707
	joint_goal[5] = -1.5707 
	
	

	move_group.go(joint_goal, wait=True)

	# Calling ``stop()`` ensures that there is no residual movement
	move_group.stop()


def image_callback(msg):
    #aruco id tespit fonksiyonu
    bridge = CvBridge()

    img = bridge.imgmsg_to_cv2(msg, desired_encoding="bgr8")
			
    h, w, _ = img.shape
    #aruco id tespit fonksiyonu
    width = 1000
    height = int(width * (h / w))
    img = cv2.resize(img, (width, height), interpolation=cv2.INTER_CUBIC)
    TARGET_CX = width // 2

    for aruco_name in ARUCO_DICT.keys():
        arucoDict = cv2.aruco.Dictionary_get(ARUCO_DICT[aruco_name])
        arucoParams = cv2.aruco.DetectorParameters_create()

        corners, ids, _ = cv2.aruco.detectMarkers(img, arucoDict, parameters=arucoParams)

        detected_markers = aruco_display(corners, ids, img)

    #cv2.imshow("Image", detected_markers)
    #cv2.waitKey(1)
def aruco_display(corners, ids, image): 
    if len(corners) > 0:
        ids = ids.flatten()

        for (markerCorner, markerID) in zip(corners, ids):
            if markerID == TARGET_MARKER_ID:
                corners = markerCorner.reshape((4, 2))
                (topLeft, topRight, bottomRight, bottomLeft) = corners

                cX = int((topLeft[0] + bottomRight[0]) / 2.0)
                cY = int((topLeft[1] + bottomRight[1]) / 2.0)
                #aruconun kameraya göre koordinatları
                cv2.circle(image, (cX, cY), 4, (0, 0, 255), -1)

                cv2.putText(image, str(markerID), (int(topLeft[0]), int(topLeft[1] - 10)), cv2.FONT_HERSHEY_SIMPLEX,
                            0.5, (0, 255, 0), 2)
                #print("[Inference] ArUco marker ID: {}".format(markerID))
                #print("[Inference] ArUco marker center: ({}, {})".format(cX, cY))

                group_name = "manipulator"
                move_group = moveit_commander.MoveGroupCommander(group_name)
                joint_goal = move_group.get_current_joint_values()
                #rviz robot koluna bağlanma

                while abs(cX - 480) > 25:  # ArUco merkezi hedefe ulaşana kadar (ekran merkezi 480 kabul edildi)
                    if cX < 480:
                        joint_goal[0] += 0.012  # Eklemleri döndür (joint_goal[0] robot eklemini temsil ediyor)
                    else:
                        joint_goal[0] -= 0.012

                    move_group.go(joint_goal, wait=True)
                    move_group.stop()
                    if abs(cX-480)<25:
                        current_pose = move_group.get_current_pose().pose
                        target_pose = geometry_msgs.msg.Pose()
                        target_pose.position.x = current_pose.position.x+0.07 #(rviz simülasyonunda x ekseninde 0.07 birim ilerleme)
                        target_pose.position.y = current_pose.position.y   
                        target_pose.position.z = current_pose.position.z
                        target_pose.orientation = current_pose.orientation

                        # Set the target pose
                        move_group.set_pose_target(target_pose)

                        # Plan and execute the motion
                        success = move_group.go(wait=True)

                        # Clear the pose target
                        move_group.clear_pose_targets()
                        move_group.stop()    
                        current_pose = move_group.get_current_pose().pose
                        joint_goal = move_group.get_current_joint_values()
                        joint_goal[0] = 0
                        joint_goal[1] = -2.09
                        joint_goal[2] = 1.745
                        joint_goal[3] = 0.349
                        joint_goal[4] = 1.5707
                        joint_goal[5] = -1.5707 
                        move_group.go(joint_goal, wait=True)
                        

	# Calling ``stop()`` ensures that there is no residual movement
	move_group.stop()
                        return all_close(target_pose, current_pose, 0.01)
 
		
                    for (markerCorner, markerID) in zip(corners, ids):
                            if markerID == TARGET_MARKER_ID: #algılanan id verilen id ile aynıysa
                                corners = markerCorner.reshape((4, 2))
                                (topLeft, topRight, bottomRight, bottomLeft) = corners

                                cX = int((topLeft[0] + bottomRight[0]) / 2.0)
                                cY = int((topLeft[1] + bottomRight[1]) / 2.0)

                                cv2.circle(image, (cX, cY), 4, (0, 0, 255), -1)

                                cv2.putText(image, str(markerID), (int(topLeft[0]), int(topLeft[1] - 10)), cv2.FONT_HERSHEY_SIMPLEX,
                                            0.5, (0, 255, 0), 2)
                		
            if markerID != TARGET_MARKER_ID:
                break
    return image
    

#alttakiler rviz robot koluna bağlanmak için tutoriallerden alındı

moveit_commander.roscpp_initialize(sys.argv)
rospy.init_node("move_group_python_interface_tutorial", anonymous=True)

robot = moveit_commander.RobotCommander()

scene = moveit_commander.PlanningSceneInterface()

group_name = "manipulator"
move_group = moveit_commander.MoveGroupCommander(group_name)

display_trajectory_publisher = rospy.Publisher(
    "/move_group/display_planned_path",
    moveit_msgs.msg.DisplayTrajectory,
    queue_size=20,
)

planning_frame = move_group.get_planning_frame()


eef_link = move_group.get_end_effector_link()


group_names = robot.get_group_names()

# Sometimes for debugging it is useful to print the entire state of the
# robot:
print(robot.get_current_state())
image_sub = rospy.Subscriber("camera_image/image_raw", Image, image_callback) #rviz kamera verisini almak
#go_to_joint_state()
#main_position()
#approach()
rospy.spin()

cv2.destroyAllWindows()
